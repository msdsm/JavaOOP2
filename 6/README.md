# セクション6:参照型の型変換

## 自分用メモ

### アップキャスト、ダウンキャスト説明
- ClassBがClassAのサブクラスとする
- ClassAでmethodXが定義されて、ClssBでmethodYが定義されているとする
- `ClassB b = new ClassB();`
    - これはClassBのインスタンスを作成して、参照型の変数bに番地を代入している
    - 100番地とする
- アップキャスト : `ClassA a = b;`
    - 同じく100番地を代入することになるが、型がClassAの参照型になる
    - もとのbのうちスーパークラスの部分だけアクセスできる
        - ここではmethodXのみアクセスできることになる
- ダウンキャスト : `ClassB b = (ClassB)a;`
    - 同じく100番地を代入することになるが、型がClassAの参照型からClassBの参照型になる
    - methodXだけではなくmethodYもアクセス可能

### アップキャスト、ダウンキャストまとめ
#### アップキャスト
- 自動型変換
- サブクラス型の変数をスーパークラス型の変数に代入できる
- アクセスできる範囲はスーパークラス部分に限定される

#### ダウンキャスト
- 明示的型変換
- インスタンスがサブクラス型の場合にスーパークラス型の変数をサブクラス型の変数に代入できる
    - インスタンスはサブクラス型だけど、そのインスタンスの番地を持っている参照型の変数はスーパークラス型への参照型という意味
- キャスト演算子を用いる
- アクセスできる範囲はサブクラス全体

#### インスタンスについて
- 変わるのは参照変数の型であってインスタンスは不変
    - a,bが100番地を持っているが、a,bの型がClassAへの参照型なのかClassBへの参照型なのかという話
    - 100番地に保存されているインスタンスの型は不変

### instanceof
- `変数名 instanceof 型名` : bool返す
- 参照型の変数に対して、その番地にあるインスタンスの型を確認するときに使う
- 例えば`ClassA a = xx;`のaに対してダウンキャストできるか調べたいとき
    - ClassBにダウンキャストできる条件はインスタンスxxがClassB型である必要がある
    - aの参照の型はClassAだがその参照先がClassBであればよい
    - `a instanceof ClassB`がtrueならダウンキャストできる

### ダイナミックバインディング
- アップキャストした変数からアップキャスト前のサブクラスでオーバーライドされたメソッドを呼び出すとサブクラスの内容が呼び出されるということ
- (重要)アクセスできる範囲は参照(変数)の型できまるが、実行する対象はインスタンス(実体)できまるから
- ClassBがClassAのサブクラスとする
- 両方のクラスでmethodYが定義されているとする(ClassBでOverride)
```java
ClassB b = new ClassB();
ClassA a = b;
a.methodY();
```
- 上記の文において、ClassBのmethodYが呼び出されるということ
- 動的に決まるからダイナミックバインディング
- 以下理由詳細に
    - bはClassB型の参照として宣言
    - aはClassA型の参照として宣言されているが、その参照先のインスタンスの型はClassB
    - `a.methodY()`について、アクセスできるかどうかは静的に参照で決まる
    - ClassAがmethodYを持つからコンパイルとおる
    - 実行すると、参照aの参照先のインスタンス(ClassB)型のmethodYが呼び出される
    - その結果ClassBで記述したmethodYが呼び出される
    - 以上がダイナミックバインディング